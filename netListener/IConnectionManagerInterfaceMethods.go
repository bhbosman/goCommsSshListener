// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/bhbosman/goCommsSshListener/sshConnectionReactor/internal (interfaces: IConnectionReactorMessageQueue)

// Package internal is a generated GoMock package.
package netListener

import (
	"context"
	fmt "fmt"
	errors "github.com/bhbosman/gocommon/errors"
	"github.com/bhbosman/gocommon/messages"
	ssh "golang.org/x/crypto/ssh"
)

// Interface A Comment
// Interface github.com/bhbosman/goCommsSshListener/sshConnectionReactor/internal
// Interface IConnectionReactorMessageQueue
// Interface IConnectionReactorMessageQueue, Method: AddAcceptedChannel
type IConnectionReactorMessageQueueAddAcceptedChannelIn struct {
	arg0 string
	arg1 messages.IApp
}

type IConnectionReactorMessageQueueAddAcceptedChannelOut struct {
	Args0 error
}
type IConnectionReactorMessageQueueAddAcceptedChannelError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionReactorMessageQueueAddAcceptedChannelError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionReactorMessageQueueAddAcceptedChannel struct {
	inData         IConnectionReactorMessageQueueAddAcceptedChannelIn
	outDataChannel chan IConnectionReactorMessageQueueAddAcceptedChannelOut
}

func NewIConnectionReactorMessageQueueAddAcceptedChannel(waitToComplete bool, arg0 string, arg1 messages.IApp) *IConnectionReactorMessageQueueAddAcceptedChannel {
	var outDataChannel chan IConnectionReactorMessageQueueAddAcceptedChannelOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionReactorMessageQueueAddAcceptedChannelOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionReactorMessageQueueAddAcceptedChannel{
		inData: IConnectionReactorMessageQueueAddAcceptedChannelIn{
			arg0: arg0,
			arg1: arg1,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionReactorMessageQueueAddAcceptedChannel) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionReactorMessageQueueAddAcceptedChannelOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionReactorMessageQueueAddAcceptedChannelError{
			InterfaceName: "IConnectionReactorMessageQueue",
			MethodName:    "AddAcceptedChannel",
			Reason:        "Channel for IConnectionReactorMessageQueue::AddAcceptedChannel returned false",
		}
		if onError != nil {
			err := onError("IConnectionReactorMessageQueue", "AddAcceptedChannel", generatedError)
			return IConnectionReactorMessageQueueAddAcceptedChannelOut{}, err
		} else {
			return IConnectionReactorMessageQueueAddAcceptedChannelOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionReactorMessageQueueAddAcceptedChannel) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionReactorMessageQueueAddAcceptedChannel(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 string, arg1 messages.IApp) (IConnectionReactorMessageQueueAddAcceptedChannelOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionReactorMessageQueueAddAcceptedChannelOut{}, context.Err()
	}
	data := NewIConnectionReactorMessageQueueAddAcceptedChannel(waitToComplete, arg0, arg1)
	if waitToComplete {
		defer func(data *IConnectionReactorMessageQueueAddAcceptedChannel) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionReactorMessageQueueAddAcceptedChannelOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionReactorMessageQueueAddAcceptedChannelOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionReactorMessageQueueAddAcceptedChannelOut{}, err
	}
	return v, nil
}

// Interface IConnectionReactorMessageQueue, Method: CanAcceptChannel
type IConnectionReactorMessageQueueCanAcceptChannelIn struct {
	arg0 string
}

type IConnectionReactorMessageQueueCanAcceptChannelOut struct {
	Args0 bool
	Args1 ssh.RejectionReason
	Args2 string
	Args3 error
}
type IConnectionReactorMessageQueueCanAcceptChannelError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionReactorMessageQueueCanAcceptChannelError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionReactorMessageQueueCanAcceptChannel struct {
	inData         IConnectionReactorMessageQueueCanAcceptChannelIn
	outDataChannel chan IConnectionReactorMessageQueueCanAcceptChannelOut
}

func NewIConnectionReactorMessageQueueCanAcceptChannel(waitToComplete bool, arg0 string) *IConnectionReactorMessageQueueCanAcceptChannel {
	var outDataChannel chan IConnectionReactorMessageQueueCanAcceptChannelOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionReactorMessageQueueCanAcceptChannelOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionReactorMessageQueueCanAcceptChannel{
		inData: IConnectionReactorMessageQueueCanAcceptChannelIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionReactorMessageQueueCanAcceptChannel) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionReactorMessageQueueCanAcceptChannelOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionReactorMessageQueueCanAcceptChannelError{
			InterfaceName: "IConnectionReactorMessageQueue",
			MethodName:    "CanAcceptChannel",
			Reason:        "Channel for IConnectionReactorMessageQueue::CanAcceptChannel returned false",
		}
		if onError != nil {
			err := onError("IConnectionReactorMessageQueue", "CanAcceptChannel", generatedError)
			return IConnectionReactorMessageQueueCanAcceptChannelOut{}, err
		} else {
			return IConnectionReactorMessageQueueCanAcceptChannelOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionReactorMessageQueueCanAcceptChannel) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionReactorMessageQueueCanAcceptChannel(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 string) (IConnectionReactorMessageQueueCanAcceptChannelOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionReactorMessageQueueCanAcceptChannelOut{}, context.Err()
	}
	data := NewIConnectionReactorMessageQueueCanAcceptChannel(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IConnectionReactorMessageQueueCanAcceptChannel) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionReactorMessageQueueCanAcceptChannelOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionReactorMessageQueueCanAcceptChannelOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionReactorMessageQueueCanAcceptChannelOut{}, err
	}
	return v, nil
}

// Interface IConnectionReactorMessageQueue, Method: HandleGlobalRequest
type IConnectionReactorMessageQueueHandleGlobalRequestIn struct {
	arg0 string
	arg1 *ssh.Request
}

type IConnectionReactorMessageQueueHandleGlobalRequestOut struct {
	Args0 error
}
type IConnectionReactorMessageQueueHandleGlobalRequestError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionReactorMessageQueueHandleGlobalRequestError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionReactorMessageQueueHandleGlobalRequest struct {
	inData         IConnectionReactorMessageQueueHandleGlobalRequestIn
	outDataChannel chan IConnectionReactorMessageQueueHandleGlobalRequestOut
}

func NewIConnectionReactorMessageQueueHandleGlobalRequest(waitToComplete bool, arg0 string, arg1 *ssh.Request) *IConnectionReactorMessageQueueHandleGlobalRequest {
	var outDataChannel chan IConnectionReactorMessageQueueHandleGlobalRequestOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionReactorMessageQueueHandleGlobalRequestOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionReactorMessageQueueHandleGlobalRequest{
		inData: IConnectionReactorMessageQueueHandleGlobalRequestIn{
			arg0: arg0,
			arg1: arg1,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionReactorMessageQueueHandleGlobalRequest) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionReactorMessageQueueHandleGlobalRequestOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionReactorMessageQueueHandleGlobalRequestError{
			InterfaceName: "IConnectionReactorMessageQueue",
			MethodName:    "HandleGlobalRequest",
			Reason:        "Channel for IConnectionReactorMessageQueue::HandleGlobalRequest returned false",
		}
		if onError != nil {
			err := onError("IConnectionReactorMessageQueue", "HandleGlobalRequest", generatedError)
			return IConnectionReactorMessageQueueHandleGlobalRequestOut{}, err
		} else {
			return IConnectionReactorMessageQueueHandleGlobalRequestOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionReactorMessageQueueHandleGlobalRequest) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionReactorMessageQueueHandleGlobalRequest(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 string, arg1 *ssh.Request) (IConnectionReactorMessageQueueHandleGlobalRequestOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionReactorMessageQueueHandleGlobalRequestOut{}, context.Err()
	}
	data := NewIConnectionReactorMessageQueueHandleGlobalRequest(waitToComplete, arg0, arg1)
	if waitToComplete {
		defer func(data *IConnectionReactorMessageQueueHandleGlobalRequest) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionReactorMessageQueueHandleGlobalRequestOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionReactorMessageQueueHandleGlobalRequestOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionReactorMessageQueueHandleGlobalRequestOut{}, err
	}
	return v, nil
}

// Interface IConnectionReactorMessageQueue, Method: RemoveAcceptedChannel
type IConnectionReactorMessageQueueRemoveAcceptedChannelIn struct {
	arg0 string
}

type IConnectionReactorMessageQueueRemoveAcceptedChannelOut struct {
	Args0 error
}
type IConnectionReactorMessageQueueRemoveAcceptedChannelError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionReactorMessageQueueRemoveAcceptedChannelError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionReactorMessageQueueRemoveAcceptedChannel struct {
	inData         IConnectionReactorMessageQueueRemoveAcceptedChannelIn
	outDataChannel chan IConnectionReactorMessageQueueRemoveAcceptedChannelOut
}

func NewIConnectionReactorMessageQueueRemoveAcceptedChannel(waitToComplete bool, arg0 string) *IConnectionReactorMessageQueueRemoveAcceptedChannel {
	var outDataChannel chan IConnectionReactorMessageQueueRemoveAcceptedChannelOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionReactorMessageQueueRemoveAcceptedChannelOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionReactorMessageQueueRemoveAcceptedChannel{
		inData: IConnectionReactorMessageQueueRemoveAcceptedChannelIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionReactorMessageQueueRemoveAcceptedChannel) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionReactorMessageQueueRemoveAcceptedChannelOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionReactorMessageQueueRemoveAcceptedChannelError{
			InterfaceName: "IConnectionReactorMessageQueue",
			MethodName:    "RemoveAcceptedChannel",
			Reason:        "Channel for IConnectionReactorMessageQueue::RemoveAcceptedChannel returned false",
		}
		if onError != nil {
			err := onError("IConnectionReactorMessageQueue", "RemoveAcceptedChannel", generatedError)
			return IConnectionReactorMessageQueueRemoveAcceptedChannelOut{}, err
		} else {
			return IConnectionReactorMessageQueueRemoveAcceptedChannelOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionReactorMessageQueueRemoveAcceptedChannel) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionReactorMessageQueueRemoveAcceptedChannel(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 string) (IConnectionReactorMessageQueueRemoveAcceptedChannelOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionReactorMessageQueueRemoveAcceptedChannelOut{}, context.Err()
	}
	data := NewIConnectionReactorMessageQueueRemoveAcceptedChannel(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IConnectionReactorMessageQueueRemoveAcceptedChannel) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionReactorMessageQueueRemoveAcceptedChannelOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionReactorMessageQueueRemoveAcceptedChannelOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionReactorMessageQueueRemoveAcceptedChannelOut{}, err
	}
	return v, nil
}

func ChannelEventsForIConnectionReactorMessageQueue(next IConnectionReactorMessageQueue, event interface{}) (bool, error) {
	switch v := event.(type) {
	case *IConnectionReactorMessageQueueAddAcceptedChannel:
		data := IConnectionReactorMessageQueueAddAcceptedChannelOut{}
		data.Args0 = next.AddAcceptedChannel(v.inData.arg0, v.inData.arg1)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IConnectionReactorMessageQueueCanAcceptChannel:
		data := IConnectionReactorMessageQueueCanAcceptChannelOut{}
		data.Args0, data.Args1, data.Args2, data.Args3 = next.CanAcceptChannel(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IConnectionReactorMessageQueueHandleGlobalRequest:
		data := IConnectionReactorMessageQueueHandleGlobalRequestOut{}
		data.Args0 = next.HandleGlobalRequest(v.inData.arg0, v.inData.arg1)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IConnectionReactorMessageQueueRemoveAcceptedChannel:
		data := IConnectionReactorMessageQueueRemoveAcceptedChannelOut{}
		data.Args0 = next.RemoveAcceptedChannel(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	default:
		return false, nil
	}
}
